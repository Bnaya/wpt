<!DOCTYPE html>
<meta charset="utf-8">
<title>Prefixed CSS Animation events</title>
<link rel="help" href="https://compat.spec.whatwg.org/#animation-event-handlers">

<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>

<style>
@keyframes anim {}
</style>

<body></body>

<script>
'use strict';

// TODO(smcgruer): Figure out timing for these tests; what is an ok time for an
// animation to run, whats the minimum to ensure we see iteration events, etc.
//
// Seems like 1ms is fine for start/end events, but iteration events require
// much longer (for both Chrome + Firefox). 50ms works for me.
//
// So all browsers collapse iteration events that occur in the same frame, and
// remove any that occur in the final frame of an animation. So we need to make
// sure that the length for the iteration tests is reasonably large for slower
// platforms... but each one will delay the test by animation-duration / 2

// Creates a div element, appends it to the document body and removes the
// created element during test cleanup.
function createDiv(test) {
  const element = document.createElement('div');
  document.body.appendChild(element);
  test.add_cleanup(() => {
    element.remove();
  });
  return element;
}

// Adds an event handler for |eventName| (calling |callback|) to the given
// |target|, that will automatically be cleaned up at the end of the test.
function addTestScopedEventHandler(test, target, eventName, callback) {
  assert_not_equals(
      target[eventName], undefined, eventName + ' must be defined');
  target[eventName] = function() {
    callback()
  };
  // We need this cleaned up even if the event handler doesn't run.
  test.add_cleanup(() => {
    target[eventName] = null;
  });
}

// Adds an event listener for |eventName| (calling |callback|) to the given
// |target|, that will automatically be cleaned up at the end of the test.
function addTestScopedEventListener(test, target, eventName, callback) {
  function listener() {
    callback();
  }
  target.addEventListener(eventName, listener);
  // We need this cleaned up even if the event handler doesn't run.
  test.add_cleanup(() => {
    target.removeEventListener(eventName, listener);
  });
}

// We use promise_tests because we need an asynchronous test model with the
// guarantee that one test will finish before another begins (since we are
// dealing with event listeners).

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationStart = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationstart', () => {
    receivedWebkitAnimationStart = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationstart', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationStart)
          resolve('success');
        else
          reject('did not receive onwebkitanimationstart event');
      });
    });
  });
}, 'onwebkitanimationstart event handler should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationIteration = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationiteration', () => {
    receivedWebkitAnimationIteration = true;
  });

  div.style.animation = 'anim 50ms 2';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationiteration', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationIteration)
          resolve('success');
        else
          resolve('did not receive onwebkitanimationiteration event');
      });
    });
  });
}, 'onwebkitanimationiteration event handler should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationEnd = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationend', () => {
    receivedWebkitAnimationEnd = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationend', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationEnd)
          resolve('success');
        else
          reject('did not receive onwebkitanimationend event');
      });
    });
  });
}, 'onwebkitanimationend event handler should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationStart = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationstart', () => {
    receivedWebkitAnimationStart = true;
  });
  addTestScopedEventHandler(t, window, 'onanimationstart', () => {});

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationstart', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationStart)
          reject('unexpectedly received onwebkitanimationstart event');
        else
          resolve('success');
      });
    });
  });
}, 'onwebkitanimationstart event handler should not trigger if an unprefixed '
    + 'version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationIteration = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationiteration', () => {
    receivedWebkitAnimationIteration = true;
  });
  addTestScopedEventHandler(t, window, 'onanimationiteration', () => {});

  div.style.animation = 'anim 50ms 2';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationiteration', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationIteration)
          reject('unexpectedly received onwebkitanimationiteration event');
        else
          resolve('success');
      });
    });
  });
}, 'onwebkitanimationiteration event handler should not trigger if an '
    + 'unprefixed version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationEnd = false;
  // TODO: use 'div' not 'window'.
  addTestScopedEventHandler(t, window, 'onwebkitanimationend', () => {
    receivedWebkitAnimationEnd = true;
  });
  addTestScopedEventHandler(t, window, 'onanimationend', () => {});

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    addTestScopedEventListener(t, div, 'animationend', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationEnd)
          reject('unexpected onwebkitanimationend event received');
        else
          resolve('success');
      });
    });
  });
}, 'onwebkitanimationend event handler should not trigger if an unprefixed '
    + 'version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationStart = false;
  addTestScopedEventListener(t, div, 'webkitAnimationStart', () => {
    receivedWebkitAnimationStart = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationstart', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationStart)
          resolve('success');
        else
          reject('did not receive webkitAnimationStart event');
      });
    });
  });
}, 'webkitAnimationStart event listener should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationIteration = false;
  addTestScopedEventListener(t, div, 'webkitAnimationIteration', () => {
    receivedWebkitAnimationIteration = true;
  });

  div.style.animation = 'anim 50ms 2';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'
    addTestScopedEventHandler(t, window, 'onanimationiteration', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationIteration)
          resolve('success');
        else
          reject('did not receive webkitAnimationIteration event');
      });
    });
  });
}, 'webkitAnimationIteration event listener should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationEnd = false;
  addTestScopedEventListener(t, div, 'webkitAnimationEnd', () => {
    receivedWebkitAnimationEnd = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationend', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationEnd)
          resolve('success');
        else
          reject('did not receive webkitAnimationEnd event');
      });
    });
  });
}, 'webkitAnimationEnd event listener should trigger');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationStart = false;
  addTestScopedEventListener(t, div, 'webkitAnimationStart', () => {
    receivedWebkitAnimationStart = true;
  });
  addTestScopedEventListener(t, div, 'animationstart', () => {});

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationstart', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationStart)
          reject('unexpectedly receieved webkitAnimationStart event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationStart event listener should not trigger if an unprefixed '
    + 'version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationIteration = false;
  addTestScopedEventListener(t, div, 'webkitAnimationIteration', () => {
    receivedWebkitAnimationIteration = true;
  });
  addTestScopedEventListener(t, div, 'animationiteration', () => {});

  div.style.animation = 'anim 50ms 2';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'
    addTestScopedEventHandler(t, window, 'onanimationiteration', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationIteration)
          reject('unexpectedly receieved webkitAnimationIteration event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationIteration event listener should not trigger if an '
    + 'unprefixed version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  let receivedWebkitAnimationEnd = false;
  addTestScopedEventListener(t, div, 'webkitAnimationEnd', () => {
    receivedWebkitAnimationEnd = true;
  });
  addTestScopedEventListener(t, div, 'animationend', () => {});

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationend', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationEnd)
          reject('unexpectedly receieved webkitAnimationEnd event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationEnd event listener should not trigger if an unprefixed '
    + 'version also exists');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  // Deliberately lower-case, to test case-sensitivity.
  let receivedWebkitAnimationStart = false;
  addTestScopedEventListener(t, div, 'webkitanimationstart', () => {
    receivedWebkitAnimationStart = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationstart', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationStart)
          reject('unexpectedly received webkitanimationstart event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationStart event listener is case sensitive');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  // Deliberately lower-case, to test case-sensitivity.
  let receivedWebkitAnimationIteration = false;
  addTestScopedEventListener(t, div, 'webkitanimationiteration', () => {
    receivedWebkitAnimationIteration = true;
  });

  div.style.animation = 'anim 50ms 2';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationiteration', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationIteration)
          reject('unexpectedly received webkitanimationiteration event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationIteration event listener is case sensitive');

promise_test(t => {
  const div = createDiv(t);
  getComputedStyle(div).offsetTop;

  // Deliberately lower-case, to test case-sensitivity.
  let receivedWebkitAnimationEnd = false;
  addTestScopedEventListener(t, div, 'webkitanimationend', () => {
    receivedWebkitAnimationEnd = true;
  });

  div.style.animation = 'anim 1ms';
  return new Promise((resolve, reject) => {
    // TODO: use 'div' not 'window'.
    addTestScopedEventHandler(t, window, 'onanimationend', () => {
      // rAF once to give the expected event time to come through.
      requestAnimationFrame(() => {
        if (receivedWebkitAnimationEnd)
          reject('unexpectedly received webkitanimationend event');
        else
          resolve('success');
      });
    });
  });
}, 'webkitAnimationEnd event listener is case sensitive');
</script>
